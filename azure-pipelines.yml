# Starter pipeline
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml

trigger:
  branches:
    include:
      - '*'
  paths:
    exclude:
      - README.md
      - azure-pipelines.yml
pr:
  branches:
    include:
      - main
  paths:
    exclude:
      - README.md
      - .gitignore
      - LICENSE

variables:
- name: applyBranch
  value:  $[eq(variables['Build.SourceBranch'], 'refs/heads/main')]
- name: tfWorkingDir
  value:  infra
- name: ansibleWorkingDir
  value: ansible
- name: terraformVersion
  value: 1.3.9


parameters:
- name: serviceConnectionName
  default: 'Azure subscription 1 (96a83b50-c77d-40ae-b8b9-4930e9787e23)'
- name: environment
  default: prod
- name: terraformVersion
  default: 1.3.9
- name: tfWorkingDirectory
  default: infra

pool:
  vmImage: ubuntu-latest

stages:
#- stage: update_shared_values
#  displayName: "Update required variable values"
#  jobs:
#    - job: update_conf
#      displayName: "Update conf toml"
#      steps:
        
#    - job: update_db
#      displayName: "Update db details"
# This is something to be done later, replacing the terraform dbname and conf.toml. and referring library variable groups in azure devops. Would make things a lot managable.

- stage: tf_plan
  displayName: "Terraform plan"
  jobs:
    - job: plan

      steps:
        - task: charleszipp.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-installer.TerraformInstaller@0
          displayName: "Use Terraform latest"
          inputs:
            terraformVersion: "${{ parameters.terraformVersion }}"

        - task: charleszipp.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-cli.TerraformCLI@0
          displayName: "Terraform format"
          inputs:
            command: fmt
            workingDirectory: "$(System.DefaultWorkingDirectory)/${{ parameters.tfWorkingDirectory }}"
            commandOptions: "-write=false -diff -recursive"

        - task: charleszipp.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-cli.TerraformCLI@0
          displayName: "Terraform Init"
          inputs:
            command: init
            workingDirectory: "$(System.DefaultWorkingDirectory)/${{ parameters.tfWorkingDirectory }}"
            commandOptions: "-reconfigure"
            backendType: local

        - task: charleszipp.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-cli.TerraformCLI@0
          displayName: "Terraform validate"
          inputs:
            workingDirectory: "$(System.DefaultWorkingDirectory)/${{ parameters.tfWorkingDirectory }}"

        - task: charleszipp.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-cli.TerraformCLI@0
          displayName: "Terraform Plan"
          inputs:
            command: plan
            workingDirectory: "$(System.DefaultWorkingDirectory)/${{ parameters.tfWorkingDirectory }}"
            environmentServiceName: "${{ parameters.serviceConnectionName }}"
            runAzLogin: true
            commandOptions: '-input=false -out="$(Build.ArtifactStagingDirectory)/tfplan-${{ parameters.environment }}"'
            publishPlanResults: "tfplan-${{ parameters.environment }}"
        - task: PublishBuildArtifacts@1
          displayName: "Publish Artifact: tfplan"
          inputs:
            PathtoPublish: "$(Build.ArtifactStagingDirectory)"
            ArtifactName: tfplan-out
    - job: approveplan
      dependsOn: plan
      pool: server
      timeoutInMinutes: 30
      steps:
        - task: ManualValidation@0
          inputs:
            instructions: "Review Terraform plan"
            notifyUsers: ''
            onTimeout:  reject


- stage: tf_apply
  displayName:  "Terraform Apply"
  dependsOn: tf_plan
  condition: | 
    and(
      succeeded(), eq(variables.applyBranch, 'true')
      )
  jobs:
    - job: apply
      steps:
        - task: DownloadPipelineArtifact@2
          inputs:
            artifact: 'tfplan-out'
            path: $(System.DefaultWorkingDirectory)
  
        - task: charleszipp.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-installer.TerraformInstaller@0
          displayName: 'Use Terraform latest'
          inputs:
            terraformVersion: '${{ parameters.terraformVersion }}'
  
        - task: charleszipp.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-cli.TerraformCLI@0
          displayName: 'Terraform Init'
          inputs:
            command: init
            workingDirectory: '$(System.DefaultWorkingDirectory)/${{ parameters.tfWorkingDirectory }}'
            commandOptions: '-reconfigure'
            backendType: local

        - task: charleszipp.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-cli.TerraformCLI@0
          displayName: 'Terraform Apply'
          inputs:
            command: apply
            workingDirectory: '$(System.DefaultWorkingDirectory)/${{ parameters.tfWorkingDirectory }}'
            environmentServiceName: '${{ parameters.serviceConnectionName }}'
            runAzLogin: true
            commandOptions: '$(System.DefaultWorkingDirectory)/tfplan-${{ parameters.environment }}"'
        
        - task: PublishBuildArtifacts@1
          inputs:
            PathtoPublish: '$(System.DefaultWorkingDirectory)/infra/appserver01-private-ip'
            ArtifactName: 'appserver01-private-ip'
            publishLocation: 'Container'
            
        - task: PublishBuildArtifacts@1
          inputs:
            PathtoPublish: '$(System.DefaultWorkingDirectory)/infra/appserver02-private-ip'
            ArtifactName: 'appserver02-private-ip'
            publishLocation: 'Container'

        - task: PublishBuildArtifacts@1
          inputs:
            PathtoPublish: '$(System.DefaultWorkingDirectory)/infra/jumpserver01-public-ip'
            ArtifactName: 'jumpserver01-public-ip'
            publishLocation: 'Container'
        

- stage: setup_jumphost
  dependsOn: tf_apply
  displayName:  "Setting up Jumphost"
  jobs:
    - job: setting_up_ips
      variables:
      - group: servchal-keys
      steps:
      - task: DownloadPipelineArtifact@2
        inputs:
          buildType: 'current'
          artifactName: 'jumpserver01-public-ip'
          targetPath: '$(System.DefaultWorkingDirectory)'

      - task: DownloadPipelineArtifact@2
        inputs:
          buildType: 'current'
          artifactName: 'appserver01-private-ip'
          targetPath: '$(System.DefaultWorkingDirectory)/infra' 

      - task: DownloadPipelineArtifact@2
        inputs:
          buildType: 'current'
          artifactName: 'appserver02-private-ip'
          targetPath: '$(System.DefaultWorkingDirectory)/infra'    
      - task: Bash@3
        displayName: "Disable hostkeychecking"
        inputs:
          targetType: 'inline'
          script: 'ssh -o StrictHostKeyChecking=no $(cat jumpserver01-public-ip)'
          workingDirectory: '$(System.DefaultWorkingDirectory)'
        continueOnError: true
      - task: DownloadSecureFile@1
        name: jumpserverkey
        inputs:
          secureFile: 'jump_serv_id_rsa'
      - task: DownloadSecureFile@1
        name: appserverkey
        inputs:
          secureFile: 'app_serv_id_rsa'

      - script: |
           echo "Copying secure file to a secure location"
           cp  $(jumpserverkey.secureFilePath) $(System.DefaultWorkingDirectory)/ansible/jump_serv_id_rsa
           chmod 0400 $(System.DefaultWorkingDirectory)/ansible/jump_serv_id_rsa
           chown $USER:USER $(System.DefaultWorkingDirectory)/ansible/jump_serv_id_rsa
           cat $(System.DefaultWorkingDirectory)/ansible/jump_serv_id_rsa 
           cp  $(appserverkey.secureFilePath) $(System.DefaultWorkingDirectory)/ansible/app_serv_id_rsa
           chmod 0400 $(System.DefaultWorkingDirectory)/ansible/app_serv_id_rsa
           cat $(System.DefaultWorkingDirectory)/ansible/app_serv_id_rsa 
        displayName: "Creating Key files"

      - script: |
           echo "[jumphosts]" >> $(System.DefaultWorkingDirectory)/ansible/inventory
           jumpip=$(cat jumpserver01-public-ip) 
           echo "${jumpip}">> $(System.DefaultWorkingDirectory)/ansible/inventory
           jumploc="$(System.DefaultWorkingDirectory)/ansible/jump_serv_id_rsa"
           echo $jumploc
           cat $jumploc
           echo "ansible_ssh_private_key_file=${jumploc}" >> $(System.DefaultWorkingDirectory)/ansible/ansible.cfg

        displayName: "Updating inventory with JumpserverIP"
      - task: Bash@3
        displayName: "Running ansible playbook to setup the jumphost"
        inputs:
          targetType: 'inline'
          script: 'ansible-playbook setupjump.yml'
          workingDirectory: '$(System.DefaultWorkingDirectory)/ansible'

- stage: deploy_application
  displayName:  "Deploying Application"
  dependsOn: setup_jumphost
  condition: succeeded()
  variables:
    - group: servchal-keys
  jobs:
    - job: deploy_app
      steps:
      - task: DownloadPipelineArtifact@2
        inputs:
          buildType: 'current'
          artifactName: 'jumpserver01-public-ip'
          targetPath: '$(System.DefaultWorkingDirectory)'
      - script: |
           jumpip=$(cat jumpserver01-public-ip)
           echo $JUMPKEY >> $(System.DefaultWorkingDirectory)/ansible/jump_serv_id_rsa
           chmod 0400 $(System.DefaultWorkingDirectory)/ansible/jump_serv_id_rsa
           ssh -i $(System.DefaultWorkingDirectory)/ansible/jump_serv_id_rsa azureuser@"${jumpip}" ansible-playbook /home/azureuser/servchal/ansible/playbook.yml --extra-vars ansible_ssh_private_key_file=/home/azureuser/servchal/ansible/app_serv_id_rsa --extra-vars ansible_user=azureuser
    - job: clean_up
      dependsOn: deploy_app
      steps:
       - script: |
           echo $JUMPKEY >> jump_serv_id_rsa
           chmod 0400 jump_serv_id_rsa
           jumpip=$(cat jumpserver01-public-ip)
           ssh -i jump_serv_id_rs azureuser@"${jumpip}" rm -rf /home/azureuser/servchal